include make_utils/globals.mk

###### Object dependencies (part 1) ######
# include the auto generated dependecies targets (if they exist)
-include $(DEPS)
#see: http://make.mad-scientist.net/papers/advanced-auto-dependency-generation/
#GCC flags to create the temporary .Td dependency file containing all header files
#that the object depends on and empty targets for each one so that if the
#header file is missing Make doesn't crash
DEP_FLAGS = -MT $(RULE_TARGET) -MMD -MP -MF $(DEP_DIR)/$*.Td
#Command to rename the temporary dependency file to a permanent .d
#dependency file. Done seperately so that failures during compilation
#won't corrupt the dependency file. Touch the object, to correct its date
POSTCOMPILE = @mv -f $(DEP_DIR)/$*.Td $(DEP_DIR)/$*.d && touch $(RULE_TARGET)

# Set the default goal to build.
.DEFAULT_GOAL = build
#$(info BUILD GOAL: $(or $(MAKECMDGOALS),$(.DEFAULT_GOAL)))

# build - builds the depenedcy projects and then the target output file itself.
# Note we need to export the variables that are needed when we recursivly call make
# on the output file target
#export OUTPUT_DIR OUTPUT_FILE CC CXX LFLAGS OBJECTS LIB_DEPS - just export them all!

.EXPORT_ALL_VARIABLES:
.PHONY: build
build: DEP_MAKE_GOAL = build
build: .build_prerequisites $(DEP_MAKE_DIRS) $(OBJECTS)
build:
	@$(MAKE) -f make_utils/common_rules.mk $(OUTPUT_DIR)/$(OUTPUT_FILE) $(SILENT_MAKE)
	@if [[ "$(POST_BUILD_TASKS)" != "" ]] ; then \
		$(ECHO) "$(COLOUR_ACT)processing $(GET_CURDIR_BASENAME)$(GET_MAKE_SUFFIX) post build tasks$(COLOUR_RST)" ; \
		$(POST_BUILD_TASKS) \
	fi ;

.build_prerequisites: | $(OUTPUT_DIRS) $(PCH_FILE_OBJ)
	@$(ECHO) 1 > .build_prerequisites
	@if [[ "$(DEP_MAKE_GOAL)" == "build" ]] ; then \
		if [[ "$(PRE_BUILD_TASKS)" != "" ]] ; then \
			$(ECHO) "$(COLOUR_ACT)processing $(GET_CURDIR_BASENAME)$(GET_MAKE_SUFFIX) pre build tasks$(COLOUR_RST)" ; \
			$(PRE_BUILD_TASKS) \
		fi ; \
		$(ECHO) "$(COLOUR_ACT)building $(GET_CURDIR_BASENAME)$(GET_MAKE_SUFFIX) ($(TARGET) $(BUILD_TYPE)): $(COLOUR_RST) $(COLOUR_DEP)[$(DEP_MAKE_DIRS)]$(COLOUR_RST)"; \
	fi ;

###### External Dependency Rules ######
# Dependency makefile directories rule (builds projects in other directories)
.PHONY: $(DEP_MAKE_DIRS)
$(DEP_MAKE_DIRS): | .build_prerequisites
	@if [ "$(FLAGS_VERBOSE)" != "" ] ; then \
		$(ECHO) "$(COLOUR_DEP)processing dependency: '$(RULE_TARGET)'$(COLOUR_RST)"; \
	fi;
	@$(MAKE) -C $(RULE_TARGET) target_$(TARGET) $(BUILD_TYPE) $(DEP_MAKE_GOAL) $(FLAGS_SUB_MAKEFILE)
	@if [ "$(FLAGS_VERBOSE)" != "" ] ; then \
		$(ECHO) "$(COLOUR_MAK)$(GET_ROOT_MAKEFILE) $(MAKECMDGOALS) ...continued ($(TARGET) $(BUILD_TYPE))$(COLOUR_RST)"; \
	fi;

###### The target rule - Linker ######
# Note: the dependencies should already be built - they are only here to trigger the rule if they have changed
$(OUTPUT_DIR)/$(OUTPUT_FILE): $(OBJECTS) $(LIB_DEPS)
	@$(ECHO) "$(COLOUR_ACT)linking: $(PROJECT_NAME)$(COLOUR_RST)"
	$(LINK_CMD)

# Rule to allow target to be dependent on the library - if the lib is not there
# then the rule is executed - this lib should have been generated by the sub-make
# files... so its an error, print it
 $(LIB_DEPS):
	@$(ECHO) "$(COLOUR_ERR)missing library: $@$(COLOUR_RST)"

###### Compile Rules ######
# Compile commands
TIME_CMD = /usr/bin/time -f "%es"
#TIME_CMD =

# Compile .cpp files
$(OBJECT_DIR)/%.o: %.cpp | .build_prerequisites
	$(CPPCHECK_BASH_CMD)
	@$(ECHO) "$(COLOUR_ACT)compiling: $(RULE_DEPENDENCY)$(COLOUR_RST)"
	$(TIME_CMD) $(CXX) $(FLAGS_CPP_WARNINGS) $(CXXFLAGS) $(DEFINES) $(DEP_FLAGS) -c $(RULE_DEPENDENCY) -o $(RULE_TARGET) $(FLAGS_PCH)
	-@$(POSTCOMPILE)
# Compile .cxx files
$(OBJECT_DIR)/%.o: %.cxx | .build_prerequisites
	$(CPPCHECK_BASH_CMD)
	@$(ECHO) "$(COLOUR_ACT)compiling: $(RULE_DEPENDENCY)$(COLOUR_RST)"
	$(TIME_CMD) $(CXX) $(FLAGS_CPP_WARNINGS) $(CXXFLAGS) $(DEFINES) $(DEP_FLAGS) -c $(RULE_DEPENDENCY) -o $(RULE_TARGET)
	-@$(POSTCOMPILE)
# Compile .c files
$(OBJECT_DIR)/%.o: %.c | .build_prerequisites
	$(CPPCHECK_BASH_CMD)
	@$(ECHO) "$(COLOUR_ACT)compiling: $(RULE_DEPENDENCY)$(COLOUR_RST)"
	$(TIME_CMD) $(CC) $(FLAGS_C_WARNINGS) $(CFLAGS) $(DEFINES) $(DEP_FLAGS) -c $(RULE_DEPENDENCY) -o $(RULE_TARGET)
	-@$(POSTCOMPILE)

###### Object dependencies (part 2) ######
#Blank dependency target in case dependency file doesn't exist to allow
#compile rule to run as usual and create a dependency file
#Mark the dependency files as precious to Make so they won't be automatically
#deleted as intermediate files
.PRECIOUS: $(DEP_DIR)/%.d
$(DEP_DIR)/%.d: ;

### Other simple rules ###

# Clean - does a target clean and also cleans the depenencies
.PHONY: clean
clean: DEP_MAKE_GOAL = clean
clean: $(DEP_MAKE_DIRS)
clean:
	@$(ECHO) "$(COLOUR_ACT)cleaning $(GET_CURDIR_BASENAME): $(TARGET) $(BUILD_TYPE)$(COLOUR_RST) $(COLOUR_DEP)[$(DEP_MAKE_DIRS)]$(COLOUR_RST)"
	$(RM) $(CLEAN_ITEMS)

# Cleanall - cleans output dirs from the root
.PHONY: cleanall
cleanall: DEP_MAKE_GOAL = cleanall
cleanall: $(DEP_MAKE_DIRS)
cleanall:
	@$(ECHO) "$(COLOUR_ACT)cleaning $(GET_CURDIR_BASENAME): all targets$(COLOUR_RST) $(COLOUR_DEP)[$(DEP_MAKE_DIRS)]$(COLOUR_RST)"
	$(RM) $(CLEANALL_ITEMS)

# Create output directories
.PHONY: create_dirs
create_dirs: $(OUTPUT_DIRS)
$(OUTPUT_DIRS):
	@if [[ "$(DEP_MAKE_GOAL)" == "build" ]] ; then \
		$(ECHO) Creating Dir: $(RULE_TARGET); \
		$(MAKE_DIR) $(RULE_TARGET); \
	fi ;

$(PCH_FILE_OBJ): $(PCH_HEADER)
	echo "create PCH file: $(RULE_TARGET)"
	$(TIME_CMD) $(CXX) $(FLAGS_CPP_WARNINGS) $(CXXFLAGS) $(DEFINES) -MT $(RULE_TARGET) -MMD -MP -MF $(RULE_TARGET).Td $(PCH_HEADER)
	echo "copy PCH file: $(RULE_TARGET)"
	mv $(PCH_HEADER).gch $(PCH_FILE_OBJ)
	echo "Creating dep: $(DEP_DIR)/$(RULE_TARGET).d"
	@mv -f $(RULE_TARGET).Td $(RULE_TARGET).d && touch $(RULE_TARGET)

# Print all the variables
VARS := $(sort $(filter-out $(VARS_OLD) VARS_OLD,$(.VARIABLES)))
.PHONY: print
print: $(VARS)
$(VARS):
	@$(ECHO) "$(COLOUR_ACT)$(RULE_TARGET):$(COLOUR_RST) $($(RULE_TARGET))"

# Print specific variable
.PHONY: print_%
print_%:
	@$(ECHO) "$(COLOUR_ACT)$*:$(COLOUR_RST) $($*)"

# Print with each item on new line
.PHONY: printf_%
printf_%:
	@$(ECHO) "$(COLOUR_ACT)$*:$(COLOUR_RST) $($*)" | tr ' ' '\n'

# Set the LD_LIBRARY_PATH needed to find all dependant libs - for convinience
.PHONY: set_ld_lib_path
set_ld_lib_path: export LD_LIBRARY_PATH = $(LD_LIBRARY_PATH_VAL)
set_ld_lib_path:
	@$(ECHO) "$(COLOUR_ACT)LD_LIBRARY_PATH:$(COLOUR_RST) $$LD_LIBRARY_PATH"

# Run the gcov command
.PHONY: run_gcov_cmd
run_gcov_cmd:
	@$(ECHO) $(GCOV_CMD)
	$(GCOV_CMD)
